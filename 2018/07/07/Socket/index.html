<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/fuck1.png"/>
	<link rel="shortcut icon" href="/img/fuck1.png">
	
			    <title>
    This is doublejian
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="C++ Python MachineLearning 程序员 后台开发" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">GO</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">学习</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Windows-10/">Windows 10</a></li><li><a class="category-link" href="/categories/后台开发/">后台开发</a></li><li><a class="category-link" href="/categories/网络/">网络</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/resume/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/picture/" title="照片">
		                照片
		            </a>
		        </li>
		        
		        <li>
		            <a href="/game/" title="游戏">
		                游戏
		            </a>
		        </li>
		        
		        <li>
		            <a href="/other/" title="其他">
		                其他
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://pic21.nipic.com/20120527/2786001_183253936000_2.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Socket</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>标签（空格分隔）： unix</p>
<hr>
<h2 id="传统Scoket编程的基本处理流程"><a href="#传统Scoket编程的基本处理流程" class="headerlink" title="传统Scoket编程的基本处理流程"></a>传统Scoket编程的基本处理流程</h2><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>服务端</p>
<blockquote>
<ul>
<li>socket（）生成一个句柄</li>
<li>设置socket属性，使用setsockopt()</li>
<li>bind（）绑定ip与端口</li>
<li>listen（）进行监听</li>
<li>当监听返回一个句柄的时候（即client的连接），获取句柄并进行accept操作</li>
<li>使用send(),recv()或者read(),write()收发数据;</li>
<li>关闭网络连接</li>
<li>关闭监听。</li>
</ul>
</blockquote>
<p>客户端</p>
<blockquote>
<ul>
<li>socket()</li>
<li>设置socket属性，使用setsockopt()</li>
<li>绑定ip、端口到socket，bind()函数  //可选</li>
<li>设置要连接的对方的IP地址和端口等属性</li>
<li>使用connect()连接服务器</li>
<li>收发数据，使用send(),recv()或者read(),write()</li>
<li>关闭连接</li>
</ul>
</blockquote>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>服务端</p>
<blockquote>
<ul>
<li>socket()</li>
<li>setsockopt()</li>
<li>bind()</li>
<li>recvfrom()</li>
<li>close()</li>
</ul>
</blockquote>
<p>客户端</p>
<blockquote>
<ul>
<li>socket()</li>
<li>setsockopt()</li>
<li>bind()   //可选</li>
<li>设置对方IP，端口等属性</li>
<li>sento()</li>
<li>close()</li>
</ul>
</blockquote>
<h2 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h2><p>主机：小端<br>网络：大端</p>
<h2 id="listen-、connect-函数"><a href="#listen-、connect-函数" class="headerlink" title="listen()、connect()函数"></a>listen()、connect()函数</h2><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct       sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>   listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。<br>    connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数去接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h2 id="read-、write-等函数"><a href="#read-、write-等函数" class="headerlink" title="read()、write()等函数"></a>read()、write()等函数</h2><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<p>read()/write()<br>recv()/send()<br>readv()/writev()<br>recvmsg()/sendmsg()<br>recvfrom()/sendto()<br>开发语言不同可能读写函数也就不同，只要把自己想要发送的消息，以字节流的方式写入Socket或者从Socket读出来即可实现网络的I/O操作。</p>
<h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h2 id="socket中TCP的三次握手建立连接"><a href="#socket中TCP的三次握手建立连接" class="headerlink" title="socket中TCP的三次握手建立连接"></a>socket中TCP的三次握手建立连接</h2><p>SYN表示建立连接，<br>FIN表示关闭连接，<br>ACK表示响应，<br>PSH表示有 DATA数据传输，<br>RST表示连接重置。</p>
<p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p>
<p>客户端向服务器发送一个SYN J<br>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1<br>客户端再想服务器发一个确认ACK K+1<br><img src="http://static.zybuluo.com/double-jian/2de0gutagw0tx4dakijf3jqs/201012122157476286.png" alt="201012122157476286.png-13.5kB"></p>
<p>当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p>
<h2 id="socket中TCP的四次握手释放连接详解"><a href="#socket中TCP的四次握手释放连接详解" class="headerlink" title="socket中TCP的四次握手释放连接详解"></a>socket中TCP的四次握手释放连接详解</h2><p><img src="http://static.zybuluo.com/double-jian/1crt71s4giekeu8hyb26oadi/201012122157494693.png" alt="201012122157494693.png-11.7kB"></p>
<p>图示过程如下：</p>
<p>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；<br>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；<br>接收到这个FIN的源发送端TCP对它进行确认。<br>这样每个方向上都有一个FIN和ACK。</p>
<h1 id="原始socket"><a href="#原始socket" class="headerlink" title="原始socket"></a>原始socket</h1><p><code>int rawsock = socket(AF_INET, SOCK_RAW, protocol);</code></p>
<p>我们平常所用到的网络编程都是在应用层收发数据，每个程序只能收到发给自己的数据，即每个程序只能收到来自该程序绑定的端口的数据。收到的数据往往只包括应用层数据。某些情况下我们需要执行更底层的操作，比如监听所有本机收发的数据、修改报头等。</p>
<p>通过原始套接字，我们可以抓取所有发送到本机的IP包（包括IP头和TCP/UDP/ICMP包头），也可以抓取所有本机收到的帧（包括数据链路层协议头）。普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以。利用原始套接字，我们可以自己构造IP头。</p>
<p>有两种原始套接字<br>一种是处理IP层即其上的数据，通过指定socket第一个参数为AF_INET来创建这种套接字。<br>另一种是处理数据链路层即其上的数据，通过指定socket第一个参数为AF_PACKET来创建这种套接字。</p>
<p>AF_INET表示获取从网络层开始的数据<br>socket(AF_INET, SOCK_RAW, …)<br>当接收包时，表示用户获得完整的包含IP报头的数据包，即数据从IP报头开始算起。<br>当发送包时，用户只能发送包含TCP报头或UDP报头或包含其他传输协议的报文，IP报头以及以太网帧头则由内核自动加封。除非是设置了IP_HDRINCL的socket选项。<br>如果第二个参数为SOCK_STREAM, SOCK_DGRAM，表示接收的数据直接为应用层数据。</p>
<p>PF_PACKET，表示获取的数据是从数据链路层开始的数据<br>socket（PF_PACKET，SOCK_RAW，htos（ETH_P_IP））：表示获得IPV4的数据链路层帧，即数据包含以太网帧头。14+20+(8:udp 或 20:tcp)<br>ETH_P_IP: 在&lt;linux/if_ether.h&gt;中定义，可以查看该文件了解支持的其它协议。<br>SOCK_RAW, SOCK_DGRAM两个参数都可以使用，区别在于使用SOCK_DGRAM收到的数据不包括数据链路层协议头。</p>
<p>总结起来就是：<br>socket(AF_INET, SOCK_RAW, IPPROTO_TCP|IPPROTO_UDP|IPPROTO_ICMP)发送接收ip数据包<br>能：该套接字可以接收协议类型为(tcp udp icmp等)发往本机的ip数据包<br>不能：收到非发往本地ip的数据包(ip软过滤会丢弃这些不是发往本机ip的数据包)<br>不能：收到从本机发送出去的数据包<br>发送的话需要自己组织tcp udp icmp等头部.可以setsockopt来自己包装ip头部<br>这种套接字用来写个ping程序比较适合</p>
<p>socket(PF_PACKET, SOCK_RAW|SOCK_DGRAM, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))发送接收以太网数据帧<br>这种套接字比较强大，可以监听网卡上的所有数据帧</p>
<p>能: 接收发往本地mac的数据帧<br>能: 接收从本机发送出去的数据帧(第3个参数需要设置为ETH_P_ALL)<br>能: 接收非发往本地mac的数据帧(网卡需要设置为promisc混杂模式)<br>协议类型一共有四个<br>ETH_P_IP 0x800 只接收发往本机mac的ip类型的数据帧<br>ETH_P_ARP 0x806 只接受发往本机mac的arp类型的数据帧<br>ETH_P_RARP 0x8035 只接受发往本机mac的rarp类型的数据帧<br>ETH_P_ALL 0x3 接收发往本机mac的所有类型ip arp rarp的数据帧, 接收从本机发出的所有类型的数据帧.(混杂模式打开的情况下,会接收到非发往本地mac的数据帧)</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: true,
        verify: false,
        app_id: 'your appId',
        app_key: 'your appkey',
        placeholder: 'Please leave your footprints',
        pageSize: '10',
        avatar: '',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
